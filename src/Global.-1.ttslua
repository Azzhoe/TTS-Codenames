--[[

  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2018  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

]]

function onload(saveState)

  -- Global variables --

  -- Global game mode
  gameMode = 0
  -- Keeps track of whether or not a new game is in the process of starting
  newGameStarting = false
  -- 0 = timer off; 1 = timer on
  timerEnabled = true
  timerOn = 1
  -- Timer warning variable
  timerWarning = -1
  -- 0 = RED; 1 = BLUE
  turnTracker = 1

  -- Illegal move tracking
  updateTimer = 0
  illegalMove = false

  -- Configuration panel settings
  playerShuffle = true
  afkProtect = true
  afkMinutes = 10
  afkTracker = {}

  -- Tracks the amount of guesses the current team has left
  guessesLeft = -1

  -- Keep track of team announcements
  announceTracker = {}

  redColor = {0.856, 0.1, 0.094}
  blueColor = {0.118, 0.53, 1}

  codeLocations =
  {
    { x = -11.4, y = 1.03, z = 12.6 }, { x = -5.7, y = 1.03, z = 12.6 }, { x = 0, y = 1.03, z = 12.6 }, { x = 5.7, y = 1.03, z = 12.6 }, { x = 11.4, y = 1.03, z = 12.6 },
    { x = -11.4, y = 1.03, z = 8.75 }, { x = -5.7, y = 1.03, z = 8.75 }, { x = 0, y = 1.03, z = 8.75 }, { x = 5.7, y = 1.03, z = 8.75 }, { x = 11.4, y = 1.03, z = 8.75 },
    { x = -11.4, y = 1.03, z = 4.9  }, { x = -5.7, y = 1.03, z = 4.9  }, { x = 0, y = 1.03, z = 4.9  }, { x = 5.7, y = 1.03, z = 4.9  }, { x = 11.4, y = 1.03, z = 4.9  },
    { x = -11.4, y = 1.03, z = 1.05 }, { x = -5.7, y = 1.03, z = 1.05 }, { x = 0, y = 1.03, z = 1.05 }, { x = 5.7, y = 1.03, z = 1.05 }, { x = 11.4, y = 1.03, z = 1.05 },
    { x = -11.4, y = 1.03, z = -2.8 }, { x = -5.7, y = 1.03, z = -2.8 }, { x = 0, y = 1.03, z = -2.8 }, { x = 5.7, y = 1.03, z = -2.8 }, { x = 11.4, y = 1.03, z = -2.8 }
  }

  agentLocations =
  {
    -- Assassain
    ['b97df2']={ 0.04, 2, -17.84 };
    -- Blue agents
    ['7fdaee']={ 12.34, 2, -13.97 }, ['99832c']={ 18.07, 2, -13.97 }, ['d9324a']={ 23.77, 2, -13.97 }, ['19b2d5']={ 29.47, 2, -13.97 },
    ['0f0ec0']={ 12.34, 2, -17.8  }, ['d9054c']={ 18.07, 2, -17.8  }, ['4de840']={ 23.77, 2, -17.8  }, ['05c73d']={ 29.47, 2, -17.8  };
    -- Red agents
    ['b48ed4']={ -29.32, 2, -13.97 }, ['6bb4d8']={ -23.62, 2, -13.97 }, ['9cbe84']={ -17.92, 2, -13.97 }, ['746660']={ -12.22, 2, -13.97 },
    ['4a2969']={ -29.32, 2, -17.8  }, ['e1754e']={ -23.62, 2, -17.8  }, ['b89ba7']={ -17.92, 2, -17.8  }, ['5c1be6']={ -12.22, 2, -17.8  };
    -- Civialians
    ['f6786b']={ -5.7, 2, -21.7 }, ['e44594']={ -5.7, 2, -17.84 }, ['1f53f2']={ -5.7, 2, -14 },
    ['f8f6a1']={ 0.04, 2, -21.7 },
    ['a05e4e']={ 5.74, 2, -21.7 }, ['1ebedd']={ 5.74, 2, -17.84 }, ['3d7b86']={ 5.74, 2, -14 };
    -- Double agents
    ['3b1be2']={ 0.04, 2, -14 };
    ['a0d86a']={ 0.04, 3, -14 };
  }

  agentColors =
  {
    -- Assassain
    ['b97df2'] = 'black',

    -- Blue agents
    ['7fdaee'] = 'blue',
    ['99832c'] = 'blue',
    ['d9324a'] = 'blue',
    ['19b2d5'] = 'blue',
    ['0f0ec0'] = 'blue',
    ['d9054c'] = 'blue',
    ['4de840'] = 'blue',
    ['05c73d'] = 'blue',

    -- Red agents
    ['b48ed4'] = 'red',
    ['6bb4d8'] = 'red',
    ['9cbe84'] = 'red',
    ['746660'] = 'red',
    ['4a2969'] = 'red',
    ['e1754e'] = 'red',
    ['b89ba7'] = 'red',
    ['5c1be6'] = 'red',

    -- Civialians
    ['f6786b'] = 'white',
    ['e44594'] = 'white',
    ['1f53f2'] = 'white',
    ['f8f6a1'] = 'white',
    ['a05e4e'] = 'white',
    ['1ebedd'] = 'white',
    ['3d7b86'] = 'white',

    -- Double agents
    ['3b1be2'] = 'blue',
    ['a0d86a'] = 'red'
  }

  -- Red clue tracker
  redClues = {}
  redCluesTracker = 0

  -- Blue clue tracker
  blueClues = {}
  blueCluesTracker = 0

  -- Tracks pickup locations of agents
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  -- Tracks correct answers
  correctTracker = {}

  -- Keeps track of the GUIDs of codes in play
  cardsInPlayArea = {}

  -- X, Z coordinates
  keymap = {
    ["-11.4,12.6"] = "", ["-5.7,12.6"] = "", ["0,12.6"] = "", ["5.7,12.6"] = "", ["11.4,12.6"] = "",
    ["-11.4,8.75"] = "", ["-5.7,8.75"] = "", ["0,8.75"] = "", ["5.7,8.75"] = "", ["11.4,8.75"] = "",
    ["-11.4,4.9"] = "", ["-5.7,4.9"] = "", ["0,4.9"] = "", ["5.7,4.9"] = "", ["11.4,4.9"] = "",
    ["-11.4,1.05"] = "", ["-5.7,1.05"] = "", ["0,1.05"] = "", ["5.7,1.05"] = "", ["11.4,1.05"] = "",
    ["-11.4,-2.8"] = "", ["-5.7,-2.8"] = "", ["0,-2.8"] = "", ["5.7,-2.8"] = "", ["11.4,-2.8"] = ""
  }
  keymapIndex = {}
  local keyIndex = 0
  for pos,_ in pairs(keymap) do
    keymapIndex[keyIndex] = pos
    keyIndex = keyIndex + 1
  end

  -- lights toggles
  spaceBG = getObjectFromGUID("7b8161")
  spaceBG.interactable = false
  spaceParticles = getObjectFromGUID("8430cf")
  spaceParticles.interactable = false
  teamlights = 1
  ambientlights = 1
  ambient_bot = getObjectFromGUID("6fb111")
  ambient_bot.interactable = false
  ambient_top = getObjectFromGUID("05032c")
  ambient_top.interactable = false
  teams_red = getObjectFromGUID("a1b2cd")
  teams_red.interactable = false
  teams_blue = getObjectFromGUID("6072b1")
  teams_blue.interactable = false

  buttonHandler = getObjectFromGUID("ec0882")
  buttonHandler.createButton({
      label="Vanilla\nCodenames", click_function="resetVanilla", function_owner=self,
      position={-5.5,0.2,-3}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Haniis\nCodenames", click_function="resetHanii", function_owner=self,
      position={-5.5,0.2,0}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="CHRYs\nCodenames", click_function="resetCHRY", function_owner=self,
      position={-1.5,0.2,-3}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Codenames:\nUndercover", click_function="resetUndercover", function_owner=self,
      position={-1.5,0.2,0}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Saydi's\nCodenames", click_function="resetSaydi", function_owner=self,
      position={-5.5,0.2,3}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Mayor's\nCodenames", click_function="resetMayor", function_owner=self,
      position={-1.5,0.2,3}, height=1200, width=1800, font_size=340, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="New Game\n(Reset)", click_function="newGame", function_owner=self,
      position={4,0.2,-3}, height=1200, width=3200, font_size=400, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Shuffle\nKeymap", click_function="shuffleKeymap", function_owner=self,
      position={4,0.2,0}, height=1200, width=3200, font_size=400, rotation={0,0,0}
  })
  buttonHandler.createButton({
      label="Reset\nClues", click_function="resetclueposition", function_owner=self,
      position={4,0.2,3}, height=1200, width=3200, font_size=400, rotation={0,0,0}
  })

  customizationPanel = getObjectFromGUID("0837df")
  local checkboxParam = {
    label="✔",
    click_function="toggleShuffle",
    function_owner=self,
    position={-6.5,0.2,-3.5},
    rotation={0,0,0},
    height=500,
    width=500,
    font_size=400
  }
  local checkboxTextParam = {
    label="Shuffle Players at Start",
    click_function="nullFunction",
    function_owner=self,
    position={-0.5,0.2,-3.4},
    rotation={0,0,0},
    height=0,
    width=0,
    font_color={1,1,1},
    font_size=500
  }
  customizationPanel.createButton(checkboxParam)
  customizationPanel.createButton(checkboxTextParam)

  checkboxParam = {
    label="✔",
    click_function="toggleAFK",
    function_owner=self,
    position={-6.5,0.2,-2.3},
    rotation={0,0,0},
    height=500,
    width=500,
    font_size=400
  }
  checkboxTextParam = {
    label="AFK Protection",
    click_function="nullFunction",
    function_owner=self,
    position={-2.4,0.2,-2.2},
    rotation={0,0,0},
    height=0,
    width=0,
    font_color={1,1,1},
    font_size=500
  }
  customizationPanel.createButton(checkboxParam)
  customizationPanel.createButton(checkboxTextParam)

  --[[ Timeout Counter ]]
  checkboxParam = {
    label="10",
    click_function="nullFunction",
    function_owner=self,
    position={-5,0.2,-1.1},
    rotation={0,0,0},
    height=500,
    width=500,
    font_size=400
  }
  checkboxTextParam = {
    label="minutes",
    click_function="nullFunction",
    function_owner=self,
    position={-2,0.2,-1},
    rotation={0,0,0},
    height=0,
    width=0,
    font_color={1,1,1},
    font_size=500
  }
  customizationPanel.createButton(checkboxParam)
  customizationPanel.createButton(checkboxTextParam)

  -- Decrement
  checkboxParam = {
    label="-",
    click_function="decAFK",
    function_owner=self,
    position={-5.8,0.2,-1.1},
    rotation={0,0,0},
    height=250,
    width=250,
    font_size=300
  }
  customizationPanel.createButton(checkboxParam)

  -- Increment
  checkboxParam = {
    label="+",
    click_function="incAFK",
    function_owner=self,
    position={-4.2,0.2,-1.1},
    rotation={0,0,0},
    height=250,
    width=250,
    font_size=300
  }
  customizationPanel.createButton(checkboxParam)
  --[[ END Timeout Counter ]]

  checkboxParam = {
    label="✔",
    click_function="toggleTimer",
    function_owner=self,
    position={-6.5,0.2,0.1},
    rotation={0,0,0},
    height=500,
    width=500,
    font_size=400,
  }
  checkboxTextParam = {
    label="Timer Enabled",
    click_function="nullFunction",
    function_owner=self,
    position={-2.4,0.2,0.2},
    rotation={0,0,0},
    height=0,
    width=0,
    font_color={1,1,1},
    font_size=500
  }
  customizationPanel.createButton(checkboxParam)
  customizationPanel.createButton(checkboxTextParam)

  customizationPanel.createButton({
      label="Shuffle Players and\nBalance Teams", click_function="shufflePlayers", function_owner=self,
      position={4,0.2,3}, height=1200, width=3200, font_size=300, rotation={0,0,0}
  })

  deckVanilla = getObjectFromGUID("83b607")
  deckHanii = getObjectFromGUID("92bb6b")
  deckCHRY = getObjectFromGUID("41f57c")
  deckUndercover = getObjectFromGUID("ee8afd")
  deckSaydi = getObjectFromGUID("d75160")
  deckMayor = getObjectFromGUID("3a3e8c")
  deckVanilla.interactable = false
  deckHanii.interactable = false
  deckCHRY.interactable = false
  deckUndercover.interactable = false
  deckSaydi.interactable = false
  deckMayor.interactable = false

  decks = {
    -- Vanilla
    [1] = deckVanilla,

    -- Hanii
    [2] = deckHanii,

    -- CHRY
    [3] = deckCHRY,

    -- Undercover
    [4] = deckUndercover,

    -- Saydi's
    [5] = deckSaydi,

    -- Mayor's
    [6] = deckMayor
  }

  clueTablet = getObjectFromGUID("69b440")
  clueTablet.interactable = false

  deckZone = getObjectFromGUID("33d9ff")

  deckDealer = getObjectFromGUID("27d226")

  -- Keymap zone
  keymapZone = getObjectFromGUID("773642")
  local zoneColor = keymapZone.getValue()
  if Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  zoneToClear = getObjectFromGUID("f71f4c")
  clueZone = getObjectFromGUID("f71f4c")

  buttonRed = getObjectFromGUID("f16a9a")
  buttonBlu = getObjectFromGUID("c91f34")
  buttonTeams = getObjectFromGUID("8a85e8")
  buttonTeams.interactable = false
  buttonTeams.setLock(true)

  -- Red team plaque position and rotation
  redPos = {-20.7, 0.91, 17.94}
  redRot = {0, 180, 0}

  -- Blue team plaque position and rotation
  bluePos = {20.7, 0.91, 17.94}
  blueRot = {0, 180, 180}

  clockTimer = getObjectFromGUID("0b1336")

  tileZone = getObjectFromGUID("06b292")

  buttonBlu.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

	buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- red clue encoder
  redToken = getObjectFromGUID("f3cdf2")
  redToken.interactable = false
  redcluezone = getObjectFromGUID("8d4638")
  blucluezone = getObjectFromGUID("61948c")

  -- blue clue encoder
  blueToken = getObjectFromGUID("3f75b3")
  blueToken.interactable = false

  tokenposition_red = 12.00
  tokenposition_blu = 12.00

  -- Codemaster encoding stations
  local inputParams = {}
  inputParams.input_function = "cluemasterEncode"
  inputParams.function_owner = self
  inputParams.tooltip = "- Enter Clue Here -"
  inputParams.label = "- Enter Clue Here -"
  inputParams.position = {0, 1, 0}
  inputParams.rotation = {0, 180, 0}
  inputParams.scale = {0.1, 10, 1/2}
  inputParams.alignment = 3
  inputParams.width = 4000
  inputParams.height = 300
  inputParams.font_size = 250
  inputParams.value = ""

  -- Blue encoding station
  blueEncoding = getObjectFromGUID("2ef93a")
  blueEncoding.setLock(true)
  blueEncoding.createInput(inputParams)
  -- Red encoding station
  redEncoding = getObjectFromGUID("7793cd")
  redEncoding.setLock(true)
  redEncoding.createInput(inputParams)

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    gameMode = decodedSaveState.gameMode
    timerEnabled = decodedSaveState.timerEnabled
    timerOn = decodedSaveState.timerOn
    timerWarning = decodedSaveState.timerWarning
    turnTracker = decodedSaveState.turnTracker
    first_random = decodedSaveState.first_random

    updateTimer = decodedSaveState.updateTimer
    illegalMove = decodedSaveState.illegalMove

    for pos, guid in pairs(JSON.decode(decodedSaveState.correctTracker)) do
      local agent = getObjectFromGUID(guid)
      if getObjectFromGUID(guid).getLock() == true then
        correctTracker[pos] = guid
        agent.interactable = false
      end
    end

    for i, cardGuid in ipairs(JSON.decode(decodedSaveState.cardsInPlayArea)) do
      cardsInPlayArea[i] = getObjectFromGUID(cardGuid)
    end

    for pos, color in pairs(JSON.decode(decodedSaveState.keymap)) do
      keymap[pos] = color
    end
  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Start the AFK loop checker
  Timer.create({
    identifier     = "afkLoop",
    function_name  = "afkCheckLoop",
    function_owner = self,
    delay          = 1,
    repetitions    = 0
  })
end

function onSave()
  local saveData = {}

  saveData.gameMode = gameMode
  saveData.timerEnabled = timerEnabled
  saveData.timerOn = timerOn
  saveData.timerWarning = timerWarning
  saveData.turnTracker = turnTracker
  saveData.first_random = first_random

  saveData.updateTimer = updateTimer
  saveData.illegalMove = illegalMove

  saveData.correctTracker = JSON.encode(correctTracker)

  local endcodedCardsInPlayArea = {}
  for i, card in ipairs(cardsInPlayArea) do
    endcodedCardsInPlayArea[i] = card.guid
  end
  saveData.cardsInPlayArea = JSON.encode(endcodedCardsInPlayArea)

  saveData.keymap = JSON.encode(keymap)

  return JSON.encode(saveData)
end

function nullFunction()
  -- Nothing
end

function decAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if afkProtect == true then
      if afkMinutes > 1 then
        afkMinutes = afkMinutes - 1
        o.editButton({
          index = 4,
          label = tostring(afkMinutes)
        })
      else
        -- Can't go above 1 minute AFK threshold
      end
    end
  end
end

function incAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if afkProtect == true then
      if afkMinutes < 60 then
        afkMinutes = afkMinutes + 1
        o.editButton({
          index = 4,
          label = tostring(afkMinutes)
        })
      else
        -- Can't go below 0 minute AFK threshold
      end
    end
  end
end

function shufflePlayers(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    startLuaCoroutine(Global, "startShuffle")
  end
end

function startShuffle()
  local seatedPlayers = Player.getPlayers()
  local players = {}
  local seats = {}
  for _, p in ipairs(seatedPlayers) do
    if p.color != "Grey" and p.color != "Black" then
      table.insert(players, p)
    end
  end
  if #players > 0 then
    local seatColors = {
      "Blue",
      "Red",
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local randSide = math.random(0,1)

    -- Remove the colors we don't need
    for i, seat in ipairs(seatColors) do
      if i <= #players then
        if #players % 2 != 0 and i == #players then
          table.insert(seats, seatColors[i + randSide])
        else
          table.insert(seats, seatColors[i])
        end
      end
    end

    -- Stand all players
    count = 0
    for _, player in ipairs(players) do
      player.changeColor("Grey")
      while count < 5 do
          count = count + 1
          coroutine.yield(0)
      end
      count = 0
    end

    -- Sit players back down
    count = 0
    for _, seat in ipairs(seats) do
      local playerIndex = math.random(1, #players)
      local randPlayer = players[playerIndex]
      table.remove(players, playerIndex)
      randPlayer.changeColor(seat)
      while count < 5 do
        count = count + 1
        coroutine.yield(0)
      end
      count = 0
    end

    -- Delay afterwards
    count = 0
    while count < 250 do
        count = count + 1
        coroutine.yield(0)
    end

    -- Continue game setup if in progress
    if newGameStarting == true then
      dealCards(cardsToDeal)
      reset_keymap()
    end
  else
    Player[color].broadcast("Not enough players to shuffle!", redColor)
  end

  return 1
end

function toggleShuffle(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    playerShuffle = not playerShuffle
    local buttonText = "✔"
    if playerShuffle == false then
      buttonText = ""
    end
    o.editButton({
      index = 0,
      label = buttonText
    })
  end
end

function afkCheckLoop()
  if afkProtect == true then
    --print(tostring(os.time()))
    local colorsToCheck = {
      "Teal",
      "Orange",
      "Purple",
      "Yellow",
      "Green",
      "Pink",
      "White",
      "Brown"
    }
    local players = Player.getPlayers()
    for _, color in ipairs(colorsToCheck) do
      local player = Player[color]
      if player.seated == true then
        -- Only if there's a player in this seat
        local playerInfo = afkTracker[color]
        local pos = player.getPointerPosition()
        if playerInfo == nil then
          -- No player information exists for this color yet
          afkTracker[color] = {
            timestamp       = os.time(),
            cursorPosition  = pos
          }
        elseif round(playerInfo.cursorPosition.x, 2) != round(pos.x, 2) or round(playerInfo.cursorPosition.y, 2) != round(pos.y, 2) or round(playerInfo.cursorPosition.z, 2) != round(pos.z, 2) then
          -- Cursor position isn't the same. log the new position
          playerInfo.timestamp = os.time()
          playerInfo.cursorPosition = pos
          afkTracker[color] = playerInfo
        else
          local timeToAFK = round((afkMinutes * 60) - (os.time() - playerInfo.timestamp), 0)
          if timeToAFK <= 0 then
            -- Switch player to spectator
            player.broadcast("You have been moved to spectator to AFKing for more than " .. tostring(afkMinutes) .. " minute(s).", redColor)
            printToAll("Player " .. player.steam_name .. " has been moved to spectator for being AFK for more than " .. tostring(afkMinutes) .. " minute(s).",  stringColorToRGB(color))
            player.changeColor("Grey")
          elseif timeToAFK <= 5 then
            player.broadcast("You will be removed due to AFK in: " .. timeToAFK, redColor)
          end
        end
      end
    end
  end
end

function toggleAFK(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    afkProtect = not afkProtect
    local buttonText = "✔"
    if afkProtect == false then
      buttonText = ""
      o.editButton({
        index = 4,
        color={0.5,0.5,0.5},
        font_color={0.25,0.25,0.25}
      })
      o.editButton({
        index = 5,
        font_color={0.25,0.25,0.25}
      })
      o.editButton({
        index = 6,
        color={0.5,0.5,0.5},
        font_color={0.25,0.25,0.25}
      })
      o.editButton({
        index = 7,
        color={0.5,0.5,0.5},
        font_color={0.25,0.25,0.25}
      })
    else
      o.editButton({
        index = 4,
        color={1,1,1},
        font_color={0,0,0}
      })
      o.editButton({
        index = 5,
        font_color={1,1,1}
      })
      o.editButton({
        index = 6,
        color={1,1,1},
        font_color={0,0,0}
      })
      o.editButton({
        index = 7,
        color={1,1,1},
        font_color={0,0,0}
      })
    end
    o.editButton({
      index = 2,
      label = buttonText
    })
  end
end

function cluemasterEncode(object, playerColor, input, selected)
  if (playerColor == "Blue" and object.guid == blueEncoding.guid) or (playerColor == "Red" and object.guid == redEncoding.guid) then
    -- Make sure that it's the current codemaster's turn
    if (playerColor == "Blue" and turnTracker == 0) or (playerColor == "Red" and turnTracker == 1) then
      Player[playerColor].broadcast("It's not your turn to enter a clue.", redColor)
      return ""
    end

    -- Handle encoding
    if string.match(input, "\n") and selected == true then
      local processedClue = processClue(input)
      if processedClue != nil then
        local clue, number = getClueDetails(processedClue)
        if clue != nil and number != nil then
          if number != "inf" and tonumber(number) > 9 then
            Player[playerColor].broadcast("Clues cannot be for more than 9 words.", redColor)
            return ""
          elseif string.len(clue) > 20 then
            Player[playerColor].broadcast("Clues cannot be longer than 20 characters.", redColor)
            return ""
          else
            -- Disable for now until I get Google TTS working
            --playClue(playerColor, clue, number)
            if number == "inf" then
              number = "∞"
              guessesLeft = -1
            elseif number == "0" then
              guessesLeft = -1
            else
              guessesLeft = tostring(number) + 1
            end
            encodeClue(playerColor, clue .. " - " .. number)
            return ""
          end
        else
          Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
          return ""
        end
      else
        Player[playerColor].broadcast("Invalid clue. Please enter a valid clue and push ENTER!", redColor)
        return ""
      end
    end
  else
    -- Player does not have permission
    local team = ""
    if object.guid == redEncoding.guid then
      team = "red"
    elseif object.guid == blueEncoding.guid then
      team = "blue"
    end

    if selected == true then
      if team != "" then
        Player[playerColor].broadcast("You don't have permission to make clues for the " .. team .. " team!", redColor)
      else
        -- Generic error message
        Player[playerColor].broadcast("You don't have permission to make clues here!", redColor)
      end
      return ""
    end
  end
end

function playClue(team, clue, number)
  local message
  if number == "inf" then
    message = "The " .. team .. " team's code is, " .. clue .. ", with infinite guesses."
  elseif number == "0" then
    message = "The " .. team .. " team's code is to avoid, " .. clue .. ", with infinite guesses."
  else
    message = "The " .. team .. " team's code is, " .. clue .. ", for " .. number
    if number == "1" then
      message = message .. " word."
    else
      message = message .. " words."
    end
  end
  local payload = {
    msg = message,
    voice = "Chris",
    engine = "1"
  }
  WebRequest.post("https://www.lumenvox.com/products/tts/processTTS.ashx", payload, self, "playClueCallback")
end

function playClueCallback(returnData)
  if returnData.is_done == true then
    local mediaFile = string.match(returnData.text, "^.+<path>(.+)</path>.+$")
    if mediaFile != nil then
      -- Ensure that the returned media file was able to be found in the return XML
      clueTablet.setValue("https://ryan6578.com/tabletopsimulator/codenames/codenames.php?tts=" .. mediaFile)
    end
  end
end

function processClue(clue)
  local result, status, error
  if clue == "" then
    -- Clue is empty
    return nil
  end

  status, result = pcall(function() return string.lower(string.gsub(clue, "\n", "")) end)
  if status != true then
    -- Error whilst removing newline
    return nil
  end

  status, result = pcall(function() return string.match(clue, "%s*(.-)%s*$") end)
  if status != true then
    -- Error whilst trimming clue
    return nil
  end

  -- No errors occured - return the formatted clue
  return string.lower(result)
end

function getClueDetails(processedClue)
  -- How many hyphens are there?
  local clue, number
  local _, hyphenCount = string.gsub(processedClue, "%-", "")
  local _, spaceCount = string.gsub(processedClue, "%s", "")

  if hyphenCount == 0 then
    -- Single word with space (or no space) as delimiter
    if spaceCount > 1 then
      return nil, nil
    end

    local checks = {
      "^(%a+)(%s*)(%d+)$",
      "^(%a+)(%s+)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status == true then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 1 then
    -- Either a hypenated word with a space (or no space) as delimiter
    -- or a single word with a hyphen (and possibly spaces) as delimiter
    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*)(%d+)$",
      "^(%a+%-%a+)(%s+)(inf)$",
      "^(%a+)(%s*%-%s*)(%d+)$",
      "^(%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status == true then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  elseif hyphenCount == 2 then

    if spaceCount > 2 then
      return nil, nil
    end

    local checks = {
      "^(%a+%-%a+)(%s*%-%s*)(%d+)$",
      "^(%a+%-%a+)(%s*%-%s*)(inf)$"
    }

    for _, check in ipairs(checks) do
      local status, clue, _, number = pcall(function() return string.match(processedClue, check) end)
      if status == true then
        -- Parsing successful - check for nil values just in case
        if clue != nil and number != nil then
          -- Return the clue and number
          return clue, number
        end
      end
    end

    -- No valid clues detected
    return nil, nil

  else
    -- Clue has too many hyphens
    return nil, nil
  end
end

function rotateclues()
  local objectsInZone = clueZone.getObjects()
  for i, object in ipairs(objectsInZone) do
    local tag = object.tag
    if tag =="Card" then
      object.setRotation({0, 180, 0})
    end
  end
end


function resetclueposition(color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    deleteclues()
    tokenposition_red = 12.00
    tokenposition_blu = 12.00
  end
end

function resetClues(color)
  deleteclues()
  tokenposition_red = 12.00
  tokenposition_blu = 12.00
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local clueColor
  local broadcastTo
  if color == "Red" then
    clueColor = redColor
    finishedClue = redToken.clone({
      position     = redToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if redCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (redCluesTracker - 1) do
        if redClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = redClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues == true then
        redCluesTracker = 0
        redClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            redCluesTracker = redCluesTracker + 1
          end
        end
      end
    end

    -- Set the red clue position
    redClues[redCluesTracker] = finishedClue
    cluePosition = {-21.05, 1.5, (12 - ((redCluesTracker % 8) * 2.05))}
    redCluesTracker = redCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Orange", "Yellow", "Pink", "Brown"}
  elseif color == "Blue" then
    clueColor = blueColor
    finishedClue = blueToken.clone({
      position     = blueToken.getPosition(),
      snap_to_grid = true
    })

    -- Check for deleted clues and reset clue positions if need be
    if blueCluesTracker > 0 then
      local deletedClues = false
      local newClueOrder = {}
      local newClueOrderIndex = 0
      for i = 0, (blueCluesTracker - 1) do
        if blueClues[i] == nil then
          deletedClues = true
        else
          newClueOrder[newClueOrderIndex] = blueClues[i]
          newClueOrderIndex = newClueOrderIndex + 1
        end
      end

      if deletedClues == true then
        blueCluesTracker = 0
        blueClues = newClueOrder
        for i = 0, (newClueOrderIndex - 1) do
          if newClueOrder[i] != nil then
            newClueOrder[i].setPosition({20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))})
            newClueOrder[i].setRotation({0, 180, 0})
            blueCluesTracker = blueCluesTracker + 1
          end
        end
      end
    end

    -- Set the blue clue position
    blueClues[blueCluesTracker] = finishedClue
    cluePosition = {20.85, 1.5, (12 - ((blueCluesTracker % 8) * 2.05))}
    blueCluesTracker = blueCluesTracker + 1

    -- Set which colors to broadcast to
    broadcastTo = {"Teal", "Purple", "Green", "White"}
  end

  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=650, width=4750, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}
  })
  finishedClue.setPosition(cluePosition)
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  printToAll(color .. " team's clue is: " .. clue, clueColor)
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("Your clue is: " .. clue, clueColor)
  end
end

function toggleAmbi()
  -- Deprecate until further notice
  --[[if ambientlights == 1 then

    ambientlights = 0

    ambient_bot.setPositionSmooth({0, -35, -26})
    ambient_top.setPositionSmooth({0, -35, 26})

  elseif ambientlights == 0 then

    ambientlights = 1

    ambient_bot.setPositionSmooth({0, 4.68, -26})
    ambient_top.setPositionSmooth({0, 4.68, 26})

  end]]
end

function toggleTeams()
  -- Deprecate until further notice
  --[[if teamlights == 1 then

    teamlights = 0

    teams_red.setPositionSmooth({-44, -35, 0})
    teams_blue.setPositionSmooth({44, -35, 0})
  elseif teamlights == 0 then

    teamlights = 1

    teams_red.setPositionSmooth({-44, 4.68, 0})
    teams_blue.setPositionSmooth({44, 4.68, 0})

  end]]
end

function toggleTimer(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    timerEnabled = not timerEnabled
    local buttonText = "✔"
    if timerEnabled == true then
      clockTimer.setValue(300)
      timerOn = 1
      printToAll("Timer Enabled", {1,1,1})
      clockTimer.Clock.pauseStart()
    else
      buttonText = ""
      timerOn = 0
      clockTimer.setValue(0)
      printToAll("Timer Disabled", {1,1,1})
    end
    o.editButton({
      index = 8,
      label = buttonText
    })
  end
end

function deleteclues()
  local tilesInZone = blucluezone.getObjects()
  for i,v in ipairs(tilesInZone) do
    if agentLocations[v.guid] == nil then
      v.destruct()
    end
  end

  local tilesInZone2 = redcluezone.getObjects()
  for i,v in ipairs(tilesInZone2) do
    if agentLocations[v.guid] == nil then
      v.destruct()
    end
  end
end

function onPlayerChangedColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team ="Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team ="None"
    end
  end

  -- Change keymap color if necessary
  local zoneColor = keymapZone.getValue()
  if color == "Blue" and zoneColor != "Blue" then
    keymapZone.setValue("Blue")
  elseif Player["Blue"].steam_id == nil and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  elseif color == "Red" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Blue"].steam_id == nil then
    keymapZone.setValue("Red")
  elseif color == "Grey" and Player["Red"].steam_id == nil then
    keymapZone.setValue("Blue")
  end

  -- Tell players which team they are on
  if color =="Red" or color =="Orange" or color =="Yellow" or color =="Pink" or color =="Brown" then
    Player[color].broadcast("You are team RED.", {0.856, 0.1, 0.094})
    --announceTeam("Red", color)
  elseif color == "Blue" or color =="Teal" or color =="Purple" or color =="Green" or color =="White" then
    Player[color].broadcast("You are team BLUE.", {0.118, 0.53, 1})
    --announceTeam("Blue", color)
  end
end

function announceTeam(team, color)
  -- Stop the UI element from showing - buggy
  --[[local attributes = {
    active = false,
    visibility = color
  }
  UI.setAttributes(color .. "Announce", attributes)

  if announceTracker[color] != nil then
    UI.hide(color .. "Announce")
    Timer.destroy(announceTracker[color])
  end]]

  local params = {}
  params.team = team
  params.color = color
  params.id = tostring(math.random())
  announceTracker[color] = params.id
  Timer.create({identifier=params.id, function_name='announceStart', parameters=params, delay=1})
end

function announceStart(params)
  local id = params.team .. "Team"
  UI.setAttribute(id, "visibility", params.color)
  UI.show(id)
  Timer.create({identifier=params.id, function_name='announceEnd', parameters=params, delay=5})
end

function announceEnd(params)
  local id = params.team .. "Team"
  UI.hide(id)
  UI.setAttribute(id, "visibility", "")
  Timer.destroy(params.id)
end

function startTime()
  clockTimer.setValue(300)
  clockTimer.Clock.pauseStart()
end

-- Deck fetching
function fetchDeck(deck)
  local chosenDeck = decks[deck]

  -- Hybrid loading - load a new deck if one doesn't exist
  if chosenDeck.tag == "Infinite" then
    local spawnedDeck = chosenDeck.takeObject({
      position  = {-9.72, -2, 17.99},
      rotation  = {0, 180, 180},
      smooth    = false
    })
    spawnedDeck.setLock(true)
    spawnedDeck.interactable = false
    chosenDeck = spawnedDeck
    decks[deck] = spawnedDeck
  end

  if chosenDeck != nil then
    local deck = chosenDeck.clone({
      position     = {-9.72, 3, 17.99},
      snap_to_grid = true
    })
    deck.setLock(false)
  end
end

-- Clear decks from dealer zone
function clearDeckZone(deckZone)
  local objectsInZone = deckZone.getObjects()
  for i, object in ipairs(objectsInZone) do
  local tag = object.tag
  if tag =="Deck" then
    destroyObject(object)
  end
end
end

-- Call functions get deck + clear deckZone
function resetVanilla(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(1)
  end
end

function resetHanii(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(2)
  end
end

function resetCHRY(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(3)
  end
end

function resetUndercover(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(4)
  end
end

function resetSaydi(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(5)
  end
end

function resetMayor(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    clearDeckZone(deckZone)
    fetchDeck(6)
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function newGame(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    if newGameStarting == false then
      local deckFound = findDeck()
      if deckFound == true then
        newGameStarting = true
        reset_agentLocations()
        resetClues()
      else
        Player[color].broadcast("You need to choose a deck before starting.", redColor)
      end
    else
      Player[color].broadcast("A new game is already starting. Please wait.", redColor)
    end
  end
end

-- Find deck on top of deck dealer
function findDeck()
    local deckObjects = deckZone.getObjects()
    local toolPos = deckDealer.getPosition()
    local toolPosX = toolPos.x
    local toolPosZ = toolPos.z

    for i, v in pairs(deckObjects) do
        if v.tag == "Deck" then
            local vPos = v.getPosition()
            local vPosX = vPos.x
            local vPosZ = vPos.z
            local dX = toolPosX - vPosX
            local dZ = toolPosZ - vPosZ
            if dX<1 and dX>-1 and dZ<1 and dZ>-1 then
              clearZone(zoneToClear)
              -- Shuffle players
              if playerShuffle == true then
                cardsToDeal = v
                startLuaCoroutine(Global, "startShuffle")
              else
                dealCards(v)
                reset_keymap()
              end
              return true
            end
        end
    end
    return false
end

-- Deals out cards from deck dealer
function dealCards(deck)
      deck.shuffle()
      local draw_parameters = {}
      draw_parameters.rotation = {0, 180, 0}
      draw_parameters.flip = true
      draw_parameters.top = true

      for i, pos in ipairs(codeLocations) do
          draw_parameters.position = pos
          local c = deck.takeObject(draw_parameters)
          cardsInPlayArea[i] = c
          local cPos = c.getPosition()
          c.setLuaScript(
            "function onLoad()\n"
                .."position = {" .. pos.x .. ", " .. pos.y .. ", " .. pos.z .. "}\n"
                .."rotation = {0, 180, 0}\n"
              .."end\n\n"

              .."function onCollisionEnter(collision_info)\n"
                .."local res, e = pcall(getObject, collision_info)\n"
                .."if res == false then\n"
                  .."self.setPosition(position)\n"
                  .."self.setRotation(rotation)\n"
                .."else\n"
                  .."if e != 'Surface' then\n"
                    .."self.setPosition(position)\n"
                    .."self.setRotation(rotation)\n"
                  .."end\n"
                .."end\n"
              .."end\n"

              .."function onCollisionStay(collision_info)\n"
                .."local res, e = pcall(getObject, collision_info)\n"
                .."if res == false then\n"
                  .."self.setPosition(position)\n"
                  .."self.setRotation(rotation)\n"
                .."else\n"
                  .."if e != 'Surface' then\n"
                    .."self.setPosition(position)\n"
                    .."self.setRotation(rotation)\n"
                  .."end\n"
                .."end\n"
              .."end\n"

              .."function onCollisionExit(collision_info)\n"
                .."local res, e = pcall(getObject, collision_info)\n"
                .."if res == false then\n"
                  .."self.setPosition(position)\n"
                  .."self.setRotation(rotation)\n"
                .."else\n"
                    .."if e != 'Surface' then\n"
                      .."self.setPosition(position)\n"
                      .."self.setRotation(rotation)\n"
                    .."end\n"
                .."end\n"
              .."end\n"

              .."function getObject(info)\n"
                .."return info.collision_object.tag\n"
              .."end\n"
          )
    end
end

-- Zone clearing
function clearZone(zoneToClear)
  local objectsInZone = zoneToClear.getObjects()
  for i, object in ipairs(objectsInZone) do
  local tag = object.tag
  if tag =="Card" then
    destroyObject(object)
  end
end
end

function shuffleKeymap(o, color)
  if color=="Red" or color=="Blue" or Player[color].promoted==true or Player[color].host==true then
    reset_keymap()
  end
end

function does_table_have_key( passed_table, passed_key )
-- checks for something in the keys (NOT the values) of a table
    for key,_ in pairs (passed_table) do
        if key == passed_key then
            return true
        end
    end
    return false
end

-- Reset the keymap
function reset_keymap()
  -- Reset game variables
  illegalMove = false
  guessesLeft = -1
  correctTracker = {}
  agentTracker = {}
  for guid, loc in pairs(agentLocations) do
    agentTracker[guid] = loc
  end

  local keymap_blue = getObjectFromGUID('65241e')
  local keymap_red = getObjectFromGUID('2ae07d')
  local keymaps = { keymap_blue, keymap_red }

  -- blue goes first = 1, red = 2
  first_random = math.random(2)

  -- put unused keymaps away under the table
  keymap_blue.lock()
  keymap_blue.setRotation( { 0, 0, 0 } )
  keymap_blue.setPosition( { 4, -0.1, 32.4 } )
  keymap_red.lock()
  keymap_red.setRotation( { 0, 0, 0 } )
  keymap_red.setPosition( { -4, -0.1, 32.4 } )

  -- put the keymap corresponding to the first turn team into position
  keymaps[first_random].setRotation( { 0, 0, 0 } )
  keymaps[first_random].setPosition( { 0, 1, -8.4 } )


  local keytile_GUIDs = { 'c7714b', 'c9ec6d', 'edd6a9', '67bb78', '53ea7a', '05e6cf', '03914a', 'e9fbf9', '50a4b1', '181f86', '94bac7', 'c68ce5', '40ca87', 'ad6ced', '29164d', '707d2b', 'e24dad', 'b64b2f', '77f492', '1ee4bf', '5b8638', 'a90289', 'a54e5b', 'd417b5', '6cb9ba' }

  local keytileColors = {
    -- Red keytiles
    ['ad6ced'] = 'red',
    ['c68ce5'] = 'red',
    ['e24dad'] = 'red',
    ['40ca87'] = 'red',
    ['181f86'] = 'red',
    ['94bac7'] = 'red',
    ['29164d'] = 'red',
    ['707d2b'] = 'red',

    -- Blue keytiles
    ['05e6cf'] = 'blue',
    ['edd6a9'] = 'blue',
    ['03914a'] = 'blue',
    ['67bb78'] = 'blue',
    ['53ea7a'] = 'blue',
    ['c9ec6d'] = 'blue',
    ['e9fbf9'] = 'blue',
    ['50a4b1'] = 'blue',

    -- White keytiles
    ['a54e5b'] = 'white',
    ['1ee4bf'] = 'white',
    ['b64b2f'] = 'white',
    ['d417b5'] = 'white',
    ['5b8638'] = 'white',
    ['a90289'] = 'white',
    ['77f492'] = 'white',

    -- Black keytile
    ['c7714b'] = 'black'

    -- Red/Blue keytile
    --['6cb9ba'] = 'redblue'
  }

  -- tile positions on grid are
  -- ~ x = { -2, -1, 0, 1, 2 }
  -- ~ y = 1.23689770698547
  -- ~ z = { -6.4, -7.4, -8.4, -9.4, -10.4 }
  local x_base = -2
  local x_step = 1
  local z_base = -6.4
  local z_step = 1
  local random_list = shuffle_table({1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25})
  for i = 0, 24, 1 do
      local current_keytile = getObjectFromGUID(keytile_GUIDs[random_list[i+1]])
      local x = x_base  +  x_step * (i%5)
      local y = 1.23689770698547
      local z = z_base  -  z_step * math.floor(i/5)
      if current_keytile.guid == "6cb9ba" then
        -- This is the red/blue keytile set based on calculated first_random
        if first_random == 1 then
          -- Blue goes first
          keymap[keymapIndex[i]] = 'blue'
          turnTracker = 1
        else
          -- Value is 2 and red goes first
          keymap[keymapIndex[i]] = 'red'
          turnTracker = 0
        end
      else
        keymap[keymapIndex[i]] = keytileColors[current_keytile.guid]
      end
      current_keytile.lock()
      current_keytile.setRotation( {0,0,0} )
      current_keytile.setPosition( {x,y,z} )
  end

  -- flip the extra tile blue side if blue goes first
  if first_random == 1 then
      local double_tile = getObjectFromGUID('6cb9ba')
      double_tile.setRotation( {0, 0, 180 } )
      -- move it upwards by its own depth because flipping changes position
      local double_tile_position = double_tile.getPosition()
      double_tile.setPosition({double_tile_position.x, double_tile_position.y+0.1, double_tile_position.z })
  end
  setDoubleTimer()
end

function shuffle_table( passed_table )
-- fisher-yates shuffle

    for current_index = #passed_table, 1, -1 do
        local swap_index = math.random(#passed_table)
        passed_table[current_index], passed_table[swap_index] = passed_table[swap_index], passed_table[current_index]
    end
    return passed_table

end


function setDoubleTimer()
  Timer.destroy("waitfortilereset")
  Timer.create({identifier="waitfortilereset", function_name='setDouble', delay=2})
end

function setDouble()
  -- Double card set to blue
  local doubleBlue = getObjectFromGUID('3b1be2')
  -- Double card set to red
  local doubleRed = getObjectFromGUID("a0d86a")

  if first_random == 1 then
    -- Change the state card to blue
    if doubleBlue == nil then
      doubleRed.setState(1)
    end

    -- Change the location of the turn marker
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  elseif first_random == 2 then
    -- Change the state card to red
    if doubleRed == nil then
      doubleBlue.setState(2)
    end

    -- Change the location of the turn marker
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  -- Set the initial timer to 600 seconds (10 minutes)
  if timerEnabled == true then
    clockTimer.setValue(600)
    timerOn = 1
    clockTimer.Clock.pauseStart()
    gameMode = 1
  end

  -- Game has successfully started
  newGameStarting = false
end

function shuffle_table( passed_table )
-- fisher-yates shuffle

    for current_index = #passed_table, 1, -1 do
        local swap_index = math.random(#passed_table)
        passed_table[current_index], passed_table[swap_index] = passed_table[swap_index], passed_table[current_index]
    end
    return passed_table

end
function reset_agentLocations()

-- resets the agent cards to their start positions
    for card_GUID,placement in pairs(agentLocations) do
        local card_object = getObjectFromGUID(card_GUID)
        if card_object then -- do not try to work with the uninstantiated card if it can't be found
            card_object.setPosition(placement)
            card_object.setRotation({0,180,180})
            card_object.unlock()
            card_object.interactable = true
        end
    end
end

function onObjectDrop(color, object)
  -- Only correct rotations when agent cards are dropped
  local isCard = false
  for i,_ in pairs(agentLocations) do
    if i == object.guid then
      isCard = true
    end
  end

  if isCard == false then
    return
  end

  local clues = clueZone.getObjects()
  local position = object.getPosition()
  local cardX = position.x
  local cardZ = position.z
  local searchThreshold = 1
  for i, v in pairs(clues) do
    local vPos = v.getPosition()
    local vPosX = vPos.x
    local vPosZ = vPos.z
    local dX = cardX - vPosX
    local dZ = cardZ - vPosZ
    if v.guid != object.guid and v.tag == "Card" and dX<searchThreshold and dX>-searchThreshold and dZ<searchThreshold and dZ>-searchThreshold then
      -- Orient cards properly
      v.setRotationSmooth({0, 180, 0})
      object.setRotationSmooth({0, 180, 180})

      -- Check to see if the agent card was placed correctly, but only if placed by blue or red
      if color == "Red" or color == "Blue" then
        --If illegal condition is set, dont allow for any more placing
        if illegalMove == true then
          object.setPositionSmooth(agentTracker[object.guid])
          return
        end

        local checkPosition = v.getPosition()
        local roundedPos = {x = round(checkPosition.x, 2), z = round(checkPosition.z, 2)}
        local correct = checkLocation(roundedPos)
        local placed
        for guid, agtColor in pairs(agentColors) do
          if guid == object.guid then
            placed = agtColor
            break
          end
        end

        if correct == placed then
          -- Card was placed correctly
          if correctTracker[roundedPos.x .. roundedPos.z] == nil then
            correctTracker[roundedPos.x .. roundedPos.z] = object.guid
            v.interactable = false
            object.interactable = false
            local lockParam = {}
            lockParam.agent = object
            lockParam.clue = v
            lockParam.id = tostring(math.random())
            Timer.create({identifier=lockParam.id, function_name='lockCorrect', parameters=lockParam, delay=1})
            -- Check to see if one team has won
            local redWon = true
            local blueWon = true
            local numred = 0
            local numblue = 0

            for guid, agtColor in pairs(agentColors) do
              if agtColor == "red" then
                if first_random == 1 and guid == "a0d86a" then
                  -- Red double agent not in use
                elseif getObjectFromGUID(guid).interactable == true then
                  numred = numred + 1
                  redWon = false
                end
              elseif agtColor == "blue" then
                if first_random == 2 and guid == "3b1be2" then
                  -- Blue double agent not in use
                elseif getObjectFromGUID(guid).interactable == true then
                  numblue = numblue + 1
                  blueWon = false
                end
              end

              -- Skip unnecessary iterations
              if redWon == false and blueWon == false then
                break
              end
            end
            -- Four scenarios:
            -- 1) white - done
            -- 2) opposite color - done
            -- 3) Black
            -- 4) Correct
            -- If card is white, or card is of the opposite color, then toggle toggleTurns
            -- 0 = RED; 1 = BLUE
            guessesLeft = guessesLeft - 1
            if correct == "black" or blueWon == true or redWon == true then
              -- End game scenario
              if (correct == "black" and turnTracker == 0) or blueWon == true then
                -- Red placed black card, blue wins
                -- or blue placed all of their cards
                broadcastToAll("Blue team wins!", blueColor)
              elseif (correct == "black" and turnTracker == 1) or redWon == true then
                -- Blue placed black card, red wins
                -- or red placed all of their cards
                broadcastToAll("Red team wins!", redColor)
              end
              -- Set the timer to 0 and disable
              timerOn = 0
              clockTimer.setValue(0)

              -- Move the remaining agents to their codes
              endGame()
            elseif guessesLeft == 0 or correct == "white" or (correct == "red" and turnTracker == 1) or (correct == "blue" and turnTracker == 0) then
              toggleTurns()
            end
          else
            object.setPositionSmooth(agentTracker[object.guid])
            Player[color].broadcast("This code has already been marked correctly.", redColor)
          end
        else
          -- Card was placed incorrectly
          illegalMove = true
        end
      else
        -- Move the placed card back to its original position
        object.setPositionSmooth(agentTracker[object.guid])
        Player[color].broadcast("Only codemasters are able to place agent cards.", redColor)
      end
    end
  end
end

function lockCorrect(params)
  local agent = params.agent
  local clue = params.clue
  agent.setLock(true)
  clue.setLock(true)

  -- Ensure the tile is on the code
  agent.setPosition(clue.getPosition())
  agent.setRotation({0, 180, 180})

  local ensureParam = {}
  ensureParam.id = math.random()
  ensureParam.agent = agent
  ensureParam.position = clue.getPosition()

  Timer.create({identifier=ensureParam.id, function_name='ensurePos', parameters=ensureParam, delay=1})

  Timer.destroy(params.id)
end

function ensurePos(params)
  local agent = params.agent

  agent.setPosition(params.position)
  agent.setRotation({0, 180, 180})

  Timer.destroy(params.id)
end

function onObjectPickUp(color, object)
  -- Clues
  if object.tag == "Card" then
    local clues = clueZone.getObjects()
    local position = object.getPosition()
    for i, v in pairs(clues) do
      if v.guid == object.guid and v.tag == "Card" then
        -- Prevent picking up of codes
        for _, card in ipairs(cardsInPlayArea) do
          if card.guid == object.guid then
            object.reload()
            break
          end
        end
      end
    end
  elseif object.tag == "Tile" and agentLocations[object.guid] != nil then
    -- Track the original locations of the tiles
    local tileZoneObj = tileZone.getObjects()
    for _, obj in pairs(tileZoneObj) do
      if obj.guid == object.guid then
        agentTracker[object.guid] = object.getPosition()
      end
    end

    -- Prevent picking up of agent tiles from anyone but red or blue
    if color != "Blue" and color != "Red" then
      for guid,_ in pairs(agentLocations) do
        if guid == object.guid then
          --object.reload()
        end
      end
    end
  end

  -- Agent dealCards
  if illegalMove == true and object.tag == "Tile" and agentColors[object.guid] != nil then
    -- Only check entire board if an error condition exists
    local boardIsCorrect = true
    local placedTiles = clueZone.getObjects()
    for _, v in pairs(placedTiles) do
      if v.guid != object.guid and v.tag == "Tile" and agentLocations[v.guid] != nil then
        local agtPos = v.getPosition();
        if checkLocation({x = agtPos.x, z = agtPos.z}) != agentColors[v.guid] then
          boardIsCorrect = false;
        end
      end
    end
    if boardIsCorrect == true then
      illegalMove = false
    end
  end
end

function endGame()

  local codesLeft = {}

  local blueAgentsLeft = {}
  local blueNum = 1
  local redAgentsLeft = {}
  local redNum = 1
  local whiteAgentsLeft = {}
  local whiteNum = 1
  local blackAgentsLeft = {}

  local numCodes = 0

  -- Get the remining codes left
  for i, pos in ipairs(codeLocations) do
    if correctTracker[pos.x .. pos.z] == nil then
      codesLeft[#codesLeft+1] = pos
      numCodes = numCodes + 1
    end
  end

  -- Get the remaining agent cards
  for guid, agtColor in pairs(agentColors) do
    if agtColor == "red" then
      if first_random == 1 and guid == "a0d86a" then
        -- Red double agent not in use
      elseif getObjectFromGUID(guid).interactable == true then
        redAgentsLeft[#redAgentsLeft+1] = guid
      end
    elseif agtColor == "blue" then
      if first_random == 2 and guid == "3b1be2" then
        -- Blue double agent not in use
      elseif getObjectFromGUID(guid).interactable == true then
        blueAgentsLeft[#blueAgentsLeft+1] = guid
      end
    elseif agtColor == "white" and getObjectFromGUID(guid).interactable == true then
      whiteAgentsLeft[#whiteAgentsLeft+1] = guid
    elseif agtColor == "black" and getObjectFromGUID(guid).interactable == true then
      blackAgentsLeft[#blackAgentsLeft+1] = guid
    end
  end

  local timeDelay = 0

  for _, pos in ipairs(codesLeft) do
    local posColor = checkLocation(pos)

    if posColor == "red" then
      agent = getObjectFromGUID(redAgentsLeft[redNum])
      redNum = redNum + 1
    elseif posColor == "blue" then
      agent = getObjectFromGUID(blueAgentsLeft[blueNum])
      blueNum = blueNum + 1
    elseif posColor == "white" then
      agent = getObjectFromGUID(whiteAgentsLeft[whiteNum])
      whiteNum = whiteNum + 1
    elseif posColor == "black" then
      agent = getObjectFromGUID(blackAgentsLeft[1])
    end

    local clues = clueZone.getObjects()
    local object = agent
    local cardX = pos.x
    local cardZ = pos.z
    local searchThreshold = 0.90
    for i, v in pairs(clues) do
      local vPos = v.getPosition()
      local vPosX = vPos.x
      local vPosZ = vPos.z
      local dX = cardX - vPosX
      local dZ = cardZ - vPosZ
      if v.guid != agent.guid and v.tag == "Card" and dX<searchThreshold and dX>-searchThreshold and dZ<searchThreshold and dZ>-searchThreshold then
        -- Orient cards properly
        local endParam = {}
        endParam.id = math.random()
        endParam.agent = agent
        endParam.code = v
        endParam.pos = pos

        Timer.create({identifier=endParam.id, function_name='endCardSet', parameters=endParam, delay=timeDelay})
      end
    end
    timeDelay = timeDelay + 0.15
  end
end

function endCardSet(endParam)
  local code = endParam.code
  local agent = endParam.agent
  local pos = endParam.pos

  code.interactable = false;
  agent.interactable = false;
  code.setLock(true)
  code.setRotationSmooth({0, 180, 0})
  agent.setRotation({0, 180, 180})
  agent.setPositionSmooth(pos)
  agent.setLock(true)

  Timer.destroy(endParam.id)
end

function onUpdate()
  -- Check for clock rundown if timer is enabled
  if timerEnabled == true then
    if gameMode == 1 and timerOn == 1 and illegalMove == false then
      local timerVal = clockTimer.getValue()
      if timerVal == 0 then
        -- Switch turns
        timerWarning = timerVal
        broadcastToAll("Time's up!", redColor)
        toggleTurns()
      elseif timerVal == 60 and timerWarning != 60 then
        timerWarning = timerVal
        broadcastToAll("1 minute remaining!", redColor)
      elseif timerVal <= 5 then
        if timerVal == 5 and timerWarning != 5 then
          timerWarning = timerVal
          broadcastToAll(timerVal .. " seconds remaining!", redColor)
        elseif timerVal == 4 and timerWarning != 4 then
          timerWarning = timerVal
          broadcastToAll(timerVal .. " seconds remaining!", redColor)
        elseif timerVal == 3 and timerWarning != 3 then
          timerWarning = timerVal
          broadcastToAll(timerVal .. " seconds remaining!", redColor)
        elseif timerVal == 2 and timerWarning != 2 then
          timerWarning = timerVal
          broadcastToAll(timerVal .. " seconds remaining!", redColor)
        elseif timerVal == 1 and timerWarning != 1 then
          timerWarning = timerVal
          broadcastToAll(timerVal .. " seconds remaining!", redColor)
        end
      end
    end
  end

  -- Notify codemasters of illegal move
  if illegalMove == true then
    if updateTimer == 100 then
      Player["Blue"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      Player["Red"].broadcast("A card has been placed incorrectly. Please correct it before ending your turn.", redColor)
      updateTimer = 0
    else
      updateTimer = updateTimer + 1
    end
  end
end

function checkLocation(position)
  for pos,color in pairs(keymap) do
    if pos == (tostring(round(position.x, 2)) .. "," .. tostring(round(position.z, 2))) then
      return color
    end
  end
end

function round(exact, precision)
   return math.floor(exact*math.pow(10,precision)+0.5) / math.pow(10,precision)
end

function toggleTurns()
  -- Reset the timer warning
  timerWarning = -1

  -- Reset the guesses each team has left
  guessesLeft = -1

  if turnTracker == 0 then
    -- Red team's turn ends, switch to blue team
    turnTracker = 1
    buttonRed.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(blueRot)
    buttonTeams.setPositionSmooth(bluePos)
    printToAll("Blue team's turn.", blueColor)
  else
    -- Blue team's turn ends, switch to red team
    turnTracker = 0
    buttonBlu.AssetBundle.playTriggerEffect(0)
    buttonTeams.setRotation(redRot)
    buttonTeams.setPositionSmooth(redPos)
    printToAll("Red team's turn.", redColor)
  end

  rotateclues()
  if timerEnabled == true and timerOn == 1 then
    startTime()
  end
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    if illegalMove == false then
      -- Is it the current side's turn?
      if turnTracker == 0 and button.guid == buttonBlu.guid or turnTracker == 1 and button.guid == buttonRed.guid then
        --Player[color].print("It's not your turn!")
        return
      end

      -- Reset the timer warning
      timerWarning = -1

      -- Reset the guesses each team has left
      guessesLeft = -1

      if turnTracker == 0 then
        -- Red team's turn ends, switch to blue team
        turnTracker = 1
        buttonRed.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(blueRot)
        buttonTeams.setPositionSmooth(bluePos)
        printToAll("Blue team's turn.", blueColor)
      else
        -- Blue team's turn ends, switch to red team
        turnTracker = 0
        buttonBlu.AssetBundle.playTriggerEffect(0)
        buttonTeams.setRotation(redRot)
        buttonTeams.setPositionSmooth(redPos)
        printToAll("Red team's turn.", redColor)
      end

      rotateclues()
      if timerEnabled == true and timerOn == 1 then
        startTime()
      end
    else
      -- Notify the person trying to end the turn that there are cards incorrectly placed on the board
      Player[color].broadcast("Please fix the incorrectly placed agent cards before ending your turn.", redColor)
    end
  end
end

function debugInfo(o, color)
  local redWon = true
  local blueWon = true
  local numred = 0
  local numblue = 0

  for guid, agtColor in pairs(agentColors) do
    if agtColor == "red" then
      if first_random == 1 and guid == "a0d86a" then
        -- Red double agent not in use
      elseif getObjectFromGUID(guid).interactable == true then
        numred = numred + 1
        redWon = false
      end
    elseif agtColor == "blue" then
      if first_random == 2 and guid == "3b1be2" then
        -- Blue double agent not in use
      elseif getObjectFromGUID(guid).interactable == true then
        numblue = numblue + 1
        blueWon = false
      end
    end
  end

  print()
  print("-----[ Game Information ]-----")
  print("gameMode=" .. gameMode)
  print("timerEnabled=" .. tostring(timerEnabled))
  print("timerOn=" .. timerOn)
  print("turnTracker=" .. (turnTracker == 0 and "red" or "blue"))
  print("illegalMove=" .. tostring(illegalMove))
  print("-----[ Winner Status ] -----")
  print("redAgentsLeft=" .. numred)
  print("redWon=" .. tostring(redWon))
  print("blueAgentsLeft=" .. numblue)
  print("blueWon=" .. tostring(blueWon))
  print()
end